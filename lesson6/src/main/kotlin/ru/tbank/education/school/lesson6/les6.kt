package ru.tbank.education.school.lesson6

// Функциональное программирование — про функции и преобразование данных
// 0) Чистые функции -> f(x) зависит только от x, без скрытых состояний
// 1) Ссылочная прозрачность -> одинаковый ввод → одинаковый вывод
// 2) Честные сигнатуры -> нет скрытых эффектов — всё видно во входах/выходах
// 3) Неизменяемость -> данные не меняются, создаётся новая версия
// 4) Нет побочных эффектов -> ничего не меняет вне себя
// 5) Композиция -> большие операции = комбинация маленьких функций



// Higher-order functions
// Любой тип функции имеет список типов параметров в скобках и тип возвращаемого значения.
// Пример: (Int, String) -> Boolean
// Если функция не принимает аргументов — список параметров пустой: () -> Int
// Если функция ничего не возвращает — возвращаемый тип Unit: () -> Unit
// Тип функции может быть nullable: ((Int) -> Int)?
// В тип функции можно добавлять имена параметров, это только для читаемости
// Функции можно вкладывать: () -> ((Int) -> Int)



// Lambda (лямбда-выражения)
// - Анонимные функции, которые можно создавать "на месте"
// - Имеют форму: { аргументы -> выражение }
// - Можно использовать "it", если один аргумент
// - Можно передавать как значение, возвращать, хранить
// - Можно использовать callable reference ::funcName

// Примеры lambda:

val sum = { a: Int, b: Int -> a + b }

val square: (Int) -> Int = { x -> x * x }

val printer: () -> Unit = { println("Hello") }

// Один аргумент → можно использовать "it"
val doubled = listOf(1, 2, 3).map { it * 2 }

// Callable reference
fun triple(x: Int) = x * 3
val t = ::triple   // тип: (Int) -> Int

// Nullable-функция
val maybeFunc: ((Int) -> Int)? = null

// Функция, возвращающая функцию
fun makeAdder(k: Int): (Int) -> Int = { x -> x + k }
val add10 = makeAdder(10)



// Invoking a function type instance
// Переменную функционального типа можно вызывать как обычную функцию.

// У любого объекта функционального типа есть оператор invoke(...)
// Поэтому вызов можно сделать двумя способами:

val f: (Int) -> Int = { x -> x + 1 }

// Полная форма
val a = f.invoke(10)

// Короткая форма (предпочтительная)
val b = f(10)

// Оба выражения эквивалентны



// Функции с receiver'ом
// Тип функции может иметь receiver type — тип объекта, на котором функция вызывается.

// Запись:  A.(B) -> C
// Это значит:
// - функцию можно вызвать на объекте типа A
// - она принимает аргумент типа B
// - возвращает значение типа C

// Пример функции с receiver'ом:

val appendHello: String.(Int) -> String =
    { times -> this + " hello".repeat(times) }

// Вызов:
val result1 = "Start".appendHello(2)

// То же самое через invoke:
val result2 = appendHello.invoke("Start", 2)

// Extension-функции фактически тоже функции с receiver'ом
fun Int.square(): Int = this * this
val x = 5.square()



// Scope functions (функции области видимости)
// Позволяют выполнить блок кода в контексте объекта и вернуть удобный результат.

// 1) let
// контекст: it
// возвращает: результат лямбды
// когда использовать: преобразование значения, работа с nullable
val r1 = "hello".let { it.uppercase() }

// 2) run
// контекст: this
// возвращает: результат лямбды
// когда использовать: конфигурация + вычисление итогового значения
val r2 = "hello".run { length * 2 }

// 3) apply
// контекст: this
// возвращает: сам объект
// когда использовать: настройка объекта (builder-style)
class User {
    var name: String = ""
    var age: Int = 0
}
val user = User().apply {
    name = "Alex"
    age = 20
}

// 4) also
// контекст: it
// возвращает: сам объект
// когда использовать: побочные действия (логирование, проверки)
val r3 = listOf(1, 2, 3).also {
    println("Size: ${it.size}")
}

// 5) with(obj)
// контекст: this
// возвращает: результат лямбды
// когда использовать: когда объект НЕ нужен после блока
val r4 = with("hello") {
    this + " world"
}
